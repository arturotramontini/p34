package main

import (
	// "p3/mudp"
	// <- questa riga sparisce quando salvo il file
	// "p3/mxxx"

	"math"
	"net"

	dati "p33/DATI"
	"p33/json"
	"p33/keys"
	"p33/mandel"
	"p33/gl41"

	"fmt"
	"image"
	"image/color"
	"image/jpeg"
	"image/png"
	"log"
	"math/big"
	"math/cmplx"
	"os"
	"runtime"
	"sync"
	"sync/atomic"
	"time"

	"github.com/go-gl/gl/v4.1-core/gl"
	"github.com/go-gl/glfw/v3.1/glfw"

	// "github.com/go-gl/gl/v4.6-compatibility/gl"
	// "github.com/go-gl/gl/v4.1-compatibility/gl"
	// "github.com/go-gl/glfw/v3.0/glfw"
	// "github.com/go-gl/gl/v3.3-compatibility/gl"
	// "github.com/go-gl/gl/v3.3-compatibility/gl"
	// "github.com/go-gl/gl/v4.2-compatibility/gl"
	//"github.com/go-gl/gl/v3.3-compatibility/gl"
	// "github.com/go-gl/gl/v4.1-core/gl"
	// "github.com/go-gl/glfw/v3.3/glfw"
)

const (
	Kw = 1000        //3504
	Kh = Kw * 9 / 16 //
	//
	winSize  = Kw * 1
	winSizeh = Kh * 1
	//
	blockSize = 100
	maxIter   = 250
	wsz1      = Kw * 1
	hsz1      = Kh * 1
)

var (
	Conn       *net.UDPConn
	LocalAddr  *net.UDPAddr
	RemoteAddr *net.UDPAddr
	Errore     error
	Flag       bool = false
	Flag2      bool = false
	F1         bool = false
	F2         bool = false
	FlagRun         = true
	Mode       int  = 0
	ch              = make(chan string) // canale globale
	conn       *net.UDPConn
	remoteAddr *net.UDPAddr
	mouseChan  = make(chan [2]float64, 10) // buffer di eventi mouse
	prec       = uint(256)
	rd         = new(big.Float).SetPrec(prec)
	cx         = new(big.Float).SetPrec(prec)
	cy         = new(big.Float).SetPrec(prec)
)

type Message struct {
	Data []byte
	Addr *net.UDPAddr
}

func printMem() {
	var m runtime.MemStats
	runtime.ReadMemStats(&m)
	fmt.Printf("Alloc = %v MiB\tTotalAlloc = %v MiB\tSys = %v MiB\tNumGC = %v\n",
		m.Alloc/1024/1024,
		m.TotalAlloc/1024/1024,
		m.Sys/1024/1024,
		m.NumGC)
}

// import mUdp "p3/mUdp"

// struttura per blocchi random
type TspiralPosition struct {
	count    int
	xDir     int
	yDir     int
	xInc     int
	yInc     int
	xPos     int
	yPos     int
	xa       int
	ya       int
	blkcnt   int
	flag     bool
	NotFirst bool
}

var sp TspiralPosition

var (
	bx      int
	by      int
	Counter int32
)

// {
// 	0,0,
// 	0,0,
// 	0,0,
// }

var pixels []uint32

// genera colori semplici in base al numero di iterazioni
func MandelbrotColor(cx, cy float64) uint32 {
	z := complex(0, 0)
	c := complex(cx, cy)
	// k := complex(0.5, -0.1)
	var n int
	for n = 0; n < maxIter; n++ {
		if cmplx.Abs(z) > 2 {
			break
		}
		z = z*z + c //*k
	}
	// mapping colore (gradiente blu)
	if n == maxIter {
		return 0xFF008000 // verdino
		// return 0xFF000000 // nero
	}
	shade := uint32(10 + (n*255)/maxIter)
	// shade := uint32(255 - (n*255)/maxIter)
	return (0xFF << 24) | (shade << 16) | (shade << 8) | 0x1f
	// return (0xFF << 24) | (shade << 16) | (shade << 8) | 0xfF
}

// calcola un blocco 8x8 di Mandelbrot
const KeachPixel = 1

func drawBlock(px, py int) {

	Vblkm := mandel.Tblkm{}
	// pVblkm := &Vblkm

	// _ = pVblkm

	//mandel.Vblkm = mandel.Tblkm{}

	Vblkm.Ny = blockSize
	Vblkm.Hy = make([]float64, blockSize)

	for y := 0; y < blockSize-0; y += KeachPixel {

		iy := py*blockSize + y
		if iy >= winSizeh || iy < 0 {
			continue
		}

		Vblkm.Iy = y
		// Vblkm.Fprimox = true

		for x := 0; x < blockSize-0; x += KeachPixel {

			Vblkm.Ix = x

			// Vblkm.Prova = float64(px)

			// for y := 0; y < 1; y++ {
			// 	for x := 0; x < 1; x++ {
			ix := px*blockSize + x
			// if ix >= winSize || iy >= winSizeh || ix < 0 || iy < 0 {
			if ix >= winSize || ix < 0 {
				continue
			}

			// mappatura coordinate nel piano complesso
			// cx := ((float64(ix)/winSize)*3.5 - 2.5) / (3.5 / 2.0)
			// cx := ((float64(ix)/winSize)*5.1 - 4.0) / (5.1 / 2.2)
			// cy := (float64(iy)/winSize)*2.2 - 1.0

			// color := mandelbrotColor(cx, cy)
			// rd := 0.20
			// mu1.Lock()
			color := uint32(0)
			switch Mode {
			case 0:
				//float32
				color = mandel.MandelColor1(ix, iy, winSize*1.0, winSizeh)
			case 1:
				//bigfloat
				color = mandel.MandelColor2(ix, iy, winSize*1.0, winSizeh, &Vblkm)
			case 2:
				//float32
				color = mandel.PaintColor1(ix, iy, winSize*1.0, winSizeh)
			}
			// mu1.Unlock()

			idx := iy*winSize + ix
			idxm := len(pixels)
			if idx >= idxm || idx < 0 {
				fmt.Println("supero limiti: ", idx, idxm)
			} else {
				pixels[(winSizeh-iy-1)*winSize+ix] = color
			}

		}
	}
	// time.Sleep(time.Millisecond * 1000)
}

// // struttura per blocchi random
// type BlockPicker struct {
// 	blocks [][2]int
// }

// func newBlockPicker(width, height, blockSize int) *BlockPicker {
// 	blocksX := width / blockSize
// 	blocksY := height / blockSize
// 	total := blocksX * blocksY
// 	blocks1xx := make([][2]int, total)
// 	k := 0
// 	for by := 0; by < blocksY; by += 1 {
// 		for bx := 0; bx < blocksX; bx += 1 {
// 			blocks1xx[k] = [2]int{bx, by}
// 			k++
// 		}
// 	}
// 	rand.Seed(time.Now().UnixNano())
// 	rand.Shuffle(len(blocks1xx), func(i, j int) {
// 		blocks1xx[i], blocks1xx[j] = blocks1xx[j], blocks1xx[i]
// 	})
// 	return &BlockPicker{blocks: blocks1xx}
// }

// func (bp *BlockPicker) Next() (bx, by int, ok bool) {
// 	if len(bp.blocks) == 0 {
// 		return 0, 0, false
// 	}
// 	b := bp.blocks[len(bp.blocks)-1]
// 	bp.blocks = bp.blocks[:len(bp.blocks)-1]
// 	return b[0], b[1], true
// }

var mu sync.Mutex

func (sp *TspiralPosition) Next1() (x, y int, ok bool, kn int) {
	mu.Lock()
	defer mu.Unlock()

	if sp.NotFirst {
		if sp.flag { //first time must be true
			switch sp.count & 3 {
			case 0:
				sp.xInc += 1
				sp.xPos += sp.xInc
			case 1:
				sp.yInc += 1
				sp.yPos -= sp.yInc
			case 2:
				sp.xInc += 1
				sp.xPos -= sp.xInc
			case 3:
				sp.yInc += 1
				sp.yPos += sp.yInc
			}
			sp.flag = false
		}

		switch sp.count & 3 {
		case 0:
			sp.xa += 1
			if sp.xa >= sp.xPos {
				sp.flag = true
				sp.count += 1
			}
		case 1:
			sp.ya -= 1
			if sp.ya <= sp.yPos {
				sp.flag = true
				sp.count += 1
			}
		case 2:
			sp.xa -= 1
			if sp.xa <= sp.xPos {
				sp.flag = true
				sp.count += 1
			}
		case 3:
			sp.ya += 1
			if sp.ya >= sp.yPos {
				sp.flag = true
				sp.count += 1
			}
		}
	} else {
		sp.NotFirst = true
	}
	x1 := winSize/blockSize/2 + sp.xa
	y1 := winSizeh/blockSize/2 + sp.ya

	// kn := winSize / blockSize * (4 / 2)
	// kn = (winSize / blockSize) + (winSizeh / blockSize)
	// kn2 := int(math.Sqrt(float64(kn1)))
	kw := int(math.Max(winSize, winSizeh))
	// kn = (winSize / blockSize) * (winSizeh / blockSize) // (conta 4 ogni blocchetto)
	kn = (kw/blockSize)*(kw/blockSize) + (kw / blockSize) // (conta 4 ogni blocchetto)
	return x1, y1, sp.blkcnt < kn, kn
}

func init() {
	runtime.LockOSThread()
}

// var mu1 sync.Mutex

func externWork() {
	// goroutine che calcola blocchi progressivamente
	go func() {
		// sp = TspiralPosition{0, 0, 0, 0, 0, 0, 0, 0, 0, true}
		// bx := winSize / blockSize / 2
		// by := winSize / blockSize / 2
		// mu1.Lock()
		// defer mu1.Unlock()

		// mu1.Lock()

		// drawBlock(bx, by)

		// sp.blkcnt = 1
		// mu1.Unlock()

		for {

			// fmt.Println(mandel.Test1)

			if !FlagRun {
				break
			}

			// bx, by, ok := picker.Next()

			// mu1.Lock()
			bx, by, ok, kn := sp.Next1()
			_ = kn
			// mu1.Unlock()
			// fmt.Printf("%5d    %3d %3d  %3d %3d %t\n", sp.count, sp.xa, sp.ya, bx, by, ok)
			// fmt.Printf("%5d   %5d  %t\n", sp.blkcnt, kn, ok)
			if !ok {
				// fmt.Printf("%5d    %3d %3d  %3d %3d %t\n", sp.count, sp.xa, sp.ya, bx, by, ok)
				if !ok {
					break
				}
			}
			// mu1.Lock()
			drawBlock(bx, by)
			sp.blkcnt += 1
			// mu1.Unlock()

			// time.Sleep(10 * time.Millisecond) // regola la velocità
			time.Sleep(10 * time.Microsecond) // regola la velocità
			// time.Sleep(10 * time.Millisecond) // Microsecond) // regola la velocità
		}
		atomic.AddInt32(&Counter, -1)
	}()
}

func Uint32ToImage(pixels []uint32, width, height int) *image.RGBA {
	img := image.NewRGBA(image.Rect(0, 0, width, height))

	for y := 0; y < height; y++ {
		// for y := height - 1; y > 0; y-- {
		for x := 0; x < width; x++ {
			idx := y*width + x
			p := pixels[idx]

			a := uint8(p >> 24)
			b := uint8(p >> 16)
			g := uint8(p >> 8)
			r := uint8(p)

			img.Set(x, height-y-1, color.RGBA{R: r, G: g, B: b, A: a})
		}
	}
	return img
}

// func repaint2() {

// 	if !F2 {
// 		return
// 	}
// 	F2 = false
// 	fmt.Println("REPAINT2")
// }

func repaint() {

	if !F1 {
		return
	}
	F1 = false
	fmt.Println("REPAINT")

	mu.Lock()
	sp.blkcnt = 1
	mu.Unlock()

	// atomic.StoreInt32(&Counter, 10)
	atomic.StoreInt32(&Counter, 1)
	externWork()
	// externWork()
	// externWork()
	// externWork()
	// externWork()
	// externWork()
	// externWork()
	// externWork()
	// externWork()
	// externWork()

	go func() {
		for {
			v := atomic.LoadInt32(&Counter)
			if v <= 0 {
				fmt.Println("FATTO.")
				if FlagRun {
					image := Uint32ToImage(pixels, winSize/1, winSizeh/1)
					f1, _ := os.Create("mandelbrot_shaded2.jpg")
					defer f1.Close()
					jpeg.Encode(f1, image, &jpeg.Options{Quality: 90})
					fmt.Println("salvato.")

					f2, _ := os.Create("mandelbrot_shaded2.png")
					defer f2.Close()
					png.Encode(f2, image)
					fmt.Println("salvato.")
				} else {
					fmt.Println("INTERROTTO")
					atomic.StoreInt32(&Counter, 0)
				}
				break
			}
		}
	}()

	if !FlagRun {
		FlagRun = true
	}
	fmt.Println("\n\n\nlen(pixels): ", len(pixels))

}

func keyCallback(w *glfw.Window, key glfw.Key, scancode int, action glfw.Action, mods glfw.ModifierKey) {
	if action == glfw.Press {
		switch key {

		// case glfw.Key0:
		// 	json.Cfg.Title = "titolo"
		// 	json.Cfg.Width = "0.123e-3"
		// 	json.Cfg.Height = "1234"

		case glfw.Key1:
			cfg, err := json.LoadConfig("config.json")
			_ = err
			json.Cfg = *cfg
			// fmt.Print("\033[20;1H", json.Cfg)
			fmt.Println(json.Cfg)

		case glfw.Key2:
			err := json.SaveConfig("config.json", &json.Cfg)
			_ = err

		case glfw.KeyEscape:
			w.SetShouldClose(true) // chiude finestra

		case glfw.KeySpace:
			log.Println("Hai premuto SPAZIO")
			printMem()
			FlagRun = !FlagRun

		case glfw.KeyUp:
			log.Println("Freccia SU")

		case glfw.KeyDown:
			log.Println("Freccia GIÙ")

		case glfw.KeyA:
			log.Println("tasto A on")
			Mode = 0
			F1 = true

			// sp = TspiralPosition{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, true}
			sp = TspiralPosition{}
			bx = winSize / blockSize / 2
			by = winSizeh / blockSize / 2
			_, _ = bx, by

			repaint()

		case glfw.KeyB:
			log.Println("tasto B on")
			Mode = 1
			F1 = true

			// sp = TspiralPosition{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, true}
			sp = TspiralPosition{}

			bx = winSize / blockSize / 2
			by = winSizeh / blockSize / 2

			repaint()

		// case glfw.KeyS:
		// 	log.Println("tasto S on") //Show
		// 	// Mode = 1
		// 	// F2 = true
		// 	// repaint()

		// 	X := dati.MouseX
		// 	Y := dati.MouseY

		// 	fmt.Printf("Mouse X,Y at: (mx:%4d, my:%4d) ---------\n", X, Y)

		// 	c := mandel.MandelColor2(X, Y, winSize, winSizeh)
		// 	fmt.Println(c)

		// 	d := mandel.MandelColor1(X, Y, winSize, winSizeh)
		// 	fmt.Println(d)

		case glfw.KeyC:
			log.Println("tasto C on")
			Flag2 = true
			clear(pixels)
			// log.Println
			// overlayImg = keys.CreateOverlay(winSize/2, winSizeh/2) // con parametri dinamici
			//***********

		case glfw.KeyD: // coloarione painting sinusoidale
			log.Println("tasto B on")
			Mode = 2
			F1 = true

			// sp = TspiralPosition{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, true}
			sp = TspiralPosition{}

			bx = winSize / blockSize / 2
			by = winSizeh / blockSize / 2

			repaint()

		case glfw.KeyX:
			// salva cx,cy,rd e calcola nuovi in base ai click mouse salvati
			log.Println("tasto X: nuovo cx,cy,rd")
			fmt.Println(Msx, Msy, Mdx, Mdy)

		}
	}
	if action == glfw.Release {
		switch key {
		case glfw.KeyEscape:
			w.SetShouldClose(true) // chiude finestra
		case glfw.KeySpace:
			log.Println("SPAZIO off")
		case glfw.KeyUp:
			log.Println("Freccia SU  off")
		case glfw.KeyDown:
			log.Println("Freccia GIÙ  off")
		case glfw.KeyA:
			log.Println("tasto A off")
		}
	}
}

var (
	//mouse destro x,y per calcolo raggio dal centro
	Mdx int
	Mdy int
	//mouse sinistro x,y per centro x,y
	Msx int
	Msy int
)

func mouseButtonCallback(w *glfw.Window, button glfw.MouseButton, action glfw.Action, mods glfw.ModifierKey) {
	if action == glfw.Press {
		switch button {
		case glfw.MouseButtonLeft:
			log.Println("Click sinistro on")
			Msx = dati.MouseX
			Msy = dati.MouseY
		case glfw.MouseButtonRight:
			log.Println("Click destro on")
			Mdx = dati.MouseX
			Mdy = dati.MouseY
		}
	}
	if action == glfw.Release {
		switch button {
		case glfw.MouseButtonLeft:
			log.Println("Click sinistro off")
		case glfw.MouseButtonRight:
			log.Println("Click destro off")
		}
	}
}

func mouseScrollCallback(w *glfw.Window, xoff, yoff float64) {
	// log.Printf("Scroll: (%.1f, %.1f)\n", xoff, yoff)

}

var (
	mouseX int32
	mouseY int32
)

var mouseInside bool = true

func cursorEnterCallback(w *glfw.Window, entered bool) {
	mouseInside = entered // true se il mouse è dentro, false se è uscito
	_ = mouseInside
	// fmt.Println("in/out:", mouseInside)
}

// var count int = 1
func mousePosCallback(w *glfw.Window, xpos, ypos float64) {
	// fmt.Println("pos in/out:", mouseInside)

	// if !mouseInside {
	// 	return
	// }

	mouseX = int32(xpos) // - winSize/2)
	mouseY = int32(ypos) //(winSizeh - int32(ypos)) //+winSizeh/2))
	// mouseY = winSizeh - 1*int32(ypos) //(winSizeh - int32(ypos)) //+winSizeh/2))
	// // mouseX = int32(xpos - winSize/2)
	// // mouseY = winSize - int32(ypos+winSizeh/2)
	_, _ = mouseX, mouseY
	dati.MouseX = int(mouseX)
	dati.MouseY = int(mouseY)

	// // // log.Printf("Mouse a: (%.1f, %.1f)\n", xpos, ypos)
	// // fmt.Printf("\033[2J\033[1;1H================")
	// fmt.Printf("\033[1;1H================")
	// fmt.Printf("\033[2;2Hcomputed Mouse XY: %4d, %4d  \033[K]", mouseX, mouseY)

	// srd, scx, scy := mandel.GetRXY(dati.MouseX, dati.MouseY, winSize, winSizeh)
	// fmt.Printf("\033[3;1Hrd: %s  \033[K", srd)
	// fmt.Printf("\033[4;1Hcx: %s  \033[K", scx)
	// fmt.Printf("\033[5;1Hcy: %s  \033[K", scy)

	keys.ShowPos(xpos, ypos)

	// text := "qui0001\n"
	// _, _ = conn.WriteToUDP([]byte(text), remoteAddr)
	// invia le coordinate al main thread
	// fmt.Println(text)
	select {
	case mouseChan <- [2]float64{xpos, ypos}:
	default:
	}
	// count += 1
	// text = fmt.Sprintf("mx:%f my:%f  cnt:%d\n", xpos, ypos, count)
	// fmt.Println(text)
}

func main() {
	// fmt.Printf("\033[2J")
	fmt.Printf("\n\n-- start p3 in floder p33 --\n\n")

	json.IniziaJson()
	// json.Cfg.Height = "1500"
	// json.SaveConfig("config.json", &json.Cfg)

	//
	Srd := ""
	Scx := ""
	Scy := ""
	SMaxiter := 100.0
	rd.SetString(Srd)
	cx.SetString(Scx)
	cy.SetString(Scy)
	Maxiter := SMaxiter
	_ = Maxiter

	localPort := "9002"
	remotePort := "9001"
	localAddr, err := net.ResolveUDPAddr("udp", ":"+localPort)
	if err != nil {
		panic(err)
	}
	remoteAddr, err = net.ResolveUDPAddr("udp", "localhost:"+remotePort)
	if err != nil {
		panic(err)
	}
	conn, err = net.ListenUDP("udp", localAddr)
	if err != nil {
		panic(err)
	}
	defer conn.Close()
	text := "qui0001\n"
	_, err = conn.WriteToUDP([]byte(text), remoteAddr)
	if err != nil {
		fmt.Println("Errore invio:", err)
		return
	}

	// ch := make(chan string)

	// // go ListenUDP(localPort, ch)

	// go func() {
	// 	for msg := range ch { // "event loop"
	// 		fmt.Printf("Evento:  %s\n", msg)
	// 		_, _ = conn.WriteToUDP([]byte(msg), remoteAddr)
	// 	}
	// }()

	// Goroutine per ricevere messaggi
	go func() {
		// S1b = "ciao2"
		buf := make([]byte, 1024)
		for {
			n, addr, err := conn.ReadFromUDP(buf)
			_ = addr
			if err != nil {
				fmt.Println("Errore ricezione:", err)
				return
			}
			s := string(buf[:n])
			// _ = S1a
			// fmt.Printf("S1a: %s \n", S1a)
			ch <- s // evento nel canale
		}
	}()
	// //
	// //
	// //
	// //----------------------------------
	// // go func() {
	// // 	localPort := "9002"
	// // 	remotePort := "9001"
	// // 	LocalAddr, Errore = net.ResolveUDPAddr("udp", ":"+localPort)
	// // 	if mudp.Errore != nil {
	// // 		panic(mudp.Errore)
	// // 	}
	// // 	// RemoteAddr, Errore := net.ResolveUDPAddr("udp", "localhost:"+remotePort)
	// // 	// _ = RemoteAddr
	// // 	// if Errore != nil {
	// // 	// 	panic(Errore)
	// // 	// }
	// 	remoteAddr, err := net.ResolveUDPAddr("udp", "localhost:"+remotePort)
	// 	if err != nil {
	// 		panic(err)
	// 	}
	// 	Conn, Errore := net.ListenUDP("udp", LocalAddr)
	// 	_ = Conn
	// 	if Errore != nil {
	// 		panic(Errore)
	// 	}
	// 	// mudp.Read_udp(Conn)
	// 	mudp.Write_udp("qui ok 1234", remoteAddr)
	// 	for {
	// 		time.Sleep(time.Millisecond * 100)
	// 	}
	// }()
	//------------------------------------------------
	//
	//
	//
	sp = TspiralPosition{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, true, false}
	bx = winSize / blockSize / 2
	by = winSizeh / blockSize / 2

	// init GLFW
	if err := glfw.Init(); err != nil {
		log.Fatalln("failed to init glfw:", err)
	}
	defer glfw.Terminate()

	// window, err := glfw.CreateWindow(winSize, winSizeh, "Mandelbrot progressivo", nil, nil)
	wws := wsz1
	whs := hsz1
	window, err := glfw.CreateWindow(wws, whs, "Mandelbrot progressivo", nil, nil)
	// window, err := glfw.CreateWindow(wsz1, hsz1, "Mandelbrot progressivo", nil, nil)
	// window, err := glfw.CreateWindow(1000, 1000, "Mandelbrot progressivo", nil, nil)
	if err != nil {
		panic(err)
	}
	window.MakeContextCurrent()

	if err := gl.Init(); err != nil {
		panic(err)
	}

	// InitOverlayGL21(winSize, winSizeh)

	// setup viewport
	gl.Viewport(0, 0, winSize/1, winSizeh/1)
	// gl.Viewport(0, 0, int32(wsz1), int32(hsz1))
	gl.MatrixMode(gl.PROJECTION)
	gl.LoadIdentity()
	gl.Ortho(0, 1, 0, 1, -1, 1)
	gl.MatrixMode(gl.MODELVIEW)

	// pixel buffer
	pixels = make([]uint32, winSize*winSizeh)

	// texture
	var tex uint32
	gl.GenTextures(1, &tex)
	gl.BindTexture(gl.TEXTURE_2D, tex)
	gl.TexParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
	gl.TexParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)

	{
		//-- non usato
		// blocchi random
		// picker := NewBlockPicker(winSize, winSizeh, blockSize)
		// _ = picker

		// // goroutine che calcola blocchi progressivamente
		// go func() {
		// 	// sp = TspiralPosition{0, 0, 0, 0, 0, 0, 0, 0, 0, true}
		// 	// bx := winSize / blockSize / 2
		// 	// by := winSize / blockSize / 2
		// 	drawBlock(bx, by)
		// 	for {
		// 		// bx, by, ok := picker.Next()

		// 		bx, by, ok := sp.Next1()
		// 		fmt.Printf("%5d    %3d %3d  %3d %3d %t\n", sp.count, sp.xa, sp.ya, bx, by, ok)
		// 		if !ok {
		// 			break
		// 		}
		// 		drawBlock(bx, by)
		// 		// time.Sleep(100 * time.Millisecond) // regola la velocità
		// 		// time.Sleep(1 * time.Microsecond) // regola la velocità
		// 		time.Sleep(10 * time.Millisecond) // Microsecond) // regola la velocità
		// 	}
		// }()
	}

	repaint()

	window.SetKeyCallback(keyCallback)
	window.SetMouseButtonCallback(mouseButtonCallback)
	window.SetScrollCallback(mouseScrollCallback)
	window.SetCursorPosCallback(mousePosCallback)
	window.SetCursorEnterCallback(cursorEnterCallback)

	//-----------
	// keys.CreateOverlay(800, 600)
	// overlayImg := keys.CreateOverlay(1024, 1024) // con parametri dinamici
	// overlayImg := keys.CreateOverlay(winSize1, winSize1/2) // con parametri dinamici
	// overlayImg := keys.CreateOverlay(1000, 1000) // con parametri dinamici
	// overlayImg := keys.CreateOverlay(winSize/2, winSizeh/2) // con parametri dinamici
	overlayImg := keys.CreateOverlay(winSize, winSizeh) // con parametri dinamici

	// // fmt.Printf("%X\n", overlayImg.(*image.RGBA).Pix)
	data := keys.RGBAtoUint32Fast(overlayImg.(*image.RGBA))
	_ = data
	// fmt.Printf("%08X\n", data)

	var texOverlay uint32
	gl.GenTextures(1, &texOverlay)
	// gl.TexImage2D(gl.TEXTURE_2D, 0, gl.RGBA,
	// 	int32(overlayImg.Bounds().Dx()), int32(overlayImg.Bounds().Dy()),
	// 	0, gl.RGBA, gl.UNSIGNED_BYTE, gl.Ptr(nil))
	// // gl.TexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, int32(overlayImg.Bounds().Dx()), int32(overlayImg.Bounds().Dy()), gl.RGBA, gl.UNSIGNED_BYTE, gl.Ptr(overlayImg.(*image.RGBA).Pix))

	gl.TexParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
	gl.TexParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)

	gl.TexParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
	gl.TexParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)

	//-----------
	oneTime1 := 1
	_ = oneTime1
	// window.SetCursorPos(0, 0)

	// main loop
	var value string = ""
	// Controlla il massimo supportato
	var maxTexSize int32
	gl.GetIntegerv(gl.MAX_TEXTURE_SIZE, &maxTexSize)
	fmt.Println("Max texture size =", maxTexSize)

	// --- Loop principale ---
	go func() {
		var count int = 1000
		for {
			count += 1
			pos := <-mouseChan
			msg := fmt.Sprintf("x=%.2f y=%.2f cnt:%d---\n", pos[0], pos[1], count)
			// conn.Write([]byte(msg))
			_, _ = conn.WriteToUDP([]byte(msg), remoteAddr)
			// fmt.Println(msg)
		}
	}()

	// for !window.ShouldClose() {

	// 	// fmt.Println("DRAW OVERLAY  1111")

	// 	// tentativo di lettura non bloccante
	// 	select {
	// 	case val := <-ch:
	// 		value = val
	// 		fmt.Println(val, "Ho letto:", value)
	// 	default:
	// 		// fmt.Println("Niente da leggere")
	// 	}

	// 	gl.Clear(gl.COLOR_BUFFER_BIT)

	// 	gl.Enable(gl.BLEND)
	// 	gl.BlendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)

	// 	// aggiorna texture dai pixels
	// 	gl.BindTexture(gl.TEXTURE_2D, tex)
	// 	gl.TexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, winSize, winSizeh, 0, gl.RGBA, gl.UNSIGNED_BYTE, gl.Ptr(pixels))
	// 	// gl.Ptr(data))
	// 	// quad a pieno schermo
	// 	gl.Enable(gl.TEXTURE_2D)
	// 	gl.Begin(gl.QUADS)
	// 	gl.TexCoord2f(0, 0)
	// 	gl.Vertex2f(0, 0)
	// 	gl.TexCoord2f(1, 0)
	// 	gl.Vertex2f(1, 0)
	// 	gl.TexCoord2f(1, 1)
	// 	gl.Vertex2f(1, 1)
	// 	gl.TexCoord2f(0, 1)
	// 	gl.Vertex2f(0, 1)
	// 	gl.End()
	// 	gl.Disable(gl.TEXTURE_2D)

	// 	// gl.TexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, wsz1, hsz1, 0, gl.RGBA, gl.UNSIGNED_BYTE, gl.Ptr(data))
	// 	// gl.TexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, winSize1, winSize1, 0, gl.RGBA, gl.UNSIGNED_BYTE, gl.Ptr(data))
	// 	gl.TexSubImage2D(gl.TEXTURE_2D, 0, mouseX, mouseY, int32(overlayImg.Bounds().Dx()), int32(overlayImg.Bounds().Dy()), gl.RGBA, gl.UNSIGNED_BYTE, gl.Ptr(overlayImg.(*image.RGBA).Pix))
	// 	// gl.TexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, int32(overlayImg.Bounds().Dx()), int32(overlayImg.Bounds().Dy()), gl.RGBA, gl.UNSIGNED_BYTE, gl.Ptr(overlayImg.(*image.RGBA).Pix))
	// 	// gl.TexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, , 0, gl.RGBA, gl.UNSIGNED_BYTE, gl.Ptr(pixels))
	// 	// gl.TexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, int32(overlayImg.Bounds().Dx()), int32(overlayImg.Bounds().Dy()), gl.RGBA, gl.UNSIGNED_BYTE, gl.Ptr(overlayImg.(*image.RGBA).Pix))
	// 	// gl.TexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, 1000, 1000, gl.RGBA, gl.UNSIGNED_BYTE, gl.Ptr(overlayImg.(*image.RGBA).Pix))
	// 	// quad a pieno schermo
	// 	gl.Enable(gl.TEXTURE_2D)
	// 	gl.Begin(gl.QUADS)
	// 	gl.TexCoord2f(0, 0)
	// 	gl.Vertex2f(0, 0)
	// 	gl.TexCoord2f(1, 0)
	// 	gl.Vertex2f(1, 0)
	// 	gl.TexCoord2f(1, 1)
	// 	gl.Vertex2f(1, 1)
	// 	gl.TexCoord2f(0, 1)
	// 	gl.Vertex2f(0, 1)
	// 	gl.End()
	// 	gl.Disable(gl.TEXTURE_2D)

	// 	// Flag2 = true
	// 	if Flag2 {
	// 		Flag2 = false
	// 		// ridipinge
	// 		// overlayImg = keys.CreateOverlay(winSize, winSizeh) // con parametri dinamici
	// 		// overlayImg = keys.CreateOverlay(winSize/2, winSizeh/2) // con parametri dinamici
	// 		// overlayImg = keys.CreateOverlay(wsz1/2, hsz1/2) // con parametri dinamici
	// 		// w := float64(wsz1)
	// 		// h := float64(hsz1)
	// 		m := math.Min(float64(winSize), float64(winSizeh)) / 10
	// 		_ = m
	// 		w := float64(winSize / 10)
	// 		h := float64(winSizeh / 20)
	// 		// w := 1000.0 * 1
	// 		// h := 200.0 * 1
	// 		overlayImg = keys.CreateOverlay(int(w*1.0), int(h*1.0)) // con parametri dinamici
	// 		//***********
	// 	}

	// 	if oneTime1 == 0 {
	// 		window.SetCursorPos(10, 400)

	// 	}
	// 	if oneTime1 > -1 {
	// 		oneTime1 -= 1
	// 	}

	// 	// // --- STOP pipeline fissa ---
	// 	// gl.Disable(gl.TEXTURE_2D)

	// 	// gl.MatrixMode(gl.PROJECTION)
	// 	// gl.LoadIdentity()

	// 	// gl.MatrixMode(gl.MODELVIEW)
	// 	// gl.LoadIdentity()

	// 	// fmt.Println("DRAW OVERLAY")

	// 	// // // --- ORA lo shader lavora correttamente ---
	// 	// DrawOverlayGL21(500, 300, 200)

	// 	// e := gl.GetError()
	// 	// if e != gl.NO_ERROR {
	// 	// 	fmt.Println("GL ERROR:", e)
	// 	// }

	// 	// gl.UseProgram(0) // torna alla pipeline fissa

	// 	// gl.Disable(gl.TEXTURE_2D) // disattiva pipeline fissa texture
	// 	// gl.MatrixMode(gl.PROJECTION)
	// 	// gl.LoadIdentity() // disattiva matrice ortho della pipeline fissa
	// 	// DrawOverlayGL21(500, 300, 200)
	// 	// DrawOverlayGL21(float32(mouseX), float32(mouseY), 120)
	// 	// gl.UseProgram(0) // torna alla pipeline fissa

	// 	// // --- Disegno TEXTURE a schermo intero ---
	// 	// gl.Enable(gl.TEXTURE_2D)
	// 	// gl.Begin(gl.QUADS)
	// 	// gl.TexCoord2f(0, 0)
	// 	// gl.Vertex2f(0, 0)
	// 	// gl.TexCoord2f(1, 0)
	// 	// gl.Vertex2f(1, 0)
	// 	// gl.TexCoord2f(1, 1)
	// 	// gl.Vertex2f(1, 1)
	// 	// gl.TexCoord2f(0, 1)
	// 	// gl.Vertex2f(0, 1)
	// 	// gl.End()
	// 	// gl.Disable(gl.TEXTURE_2D)

	// 	// // --- RIPRISTINO MATRICE ORTHO (per fixed pipeline) ---
	// 	// gl.MatrixMode(gl.PROJECTION)
	// 	// gl.LoadIdentity()
	// 	// gl.Ortho(0, 1, 0, 1, -1, 1)
	// 	// gl.MatrixMode(gl.MODELVIEW)
	// 	// gl.LoadIdentity()

	// 	gl.Disable(gl.TEXTURE_2D)

	// 	// --- RESET pipeline fissa per usare SHADER ---
	// 	gl.MatrixMode(gl.PROJECTION)
	// 	gl.LoadIdentity()
	// 	gl.MatrixMode(gl.MODELVIEW)
	// 	gl.LoadIdentity()

	// 	// --- Disegna overlay ---
	// 	DrawOverlayGL21(float32(mouseX), float32(mouseY), 200)
	// 	e := gl.GetError()
	// 	if e != gl.NO_ERROR {
	// 		fmt.Println("GL ERROR:", e)
	// 	}

	// 	// --- RITORNO ALLA PIPELINE FISSA ---
	// 	gl.UseProgram(0)

	// 	window.SwapBuffers()
	// 	glfw.PollEvents()
	// }

	for !window.ShouldClose() {

		// --- EVENTI UDP (non blocca)
		select {
		case val := <-ch:
			value = val
			fmt.Println(val, "Ho letto:", value)
		default:
		}

		gl.Clear(gl.COLOR_BUFFER_BIT)

		gl.Enable(gl.BLEND)
		gl.BlendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)

		// ----------------------------------------------------
		// 1) DISEGNO DELLA TEXTURE (fixed pipeline)
		// ----------------------------------------------------

		gl.BindTexture(gl.TEXTURE_2D, tex)
		gl.TexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, winSize, winSizeh, 0, gl.RGBA,
			gl.UNSIGNED_BYTE, gl.Ptr(pixels))

		// ----------------------------------------------------
		// 1) MATRICE PER TEXTURE (fixed pipeline: 0..1 in 0..1)
		// ----------------------------------------------------
		gl.MatrixMode(gl.PROJECTION)
		gl.LoadIdentity()
		gl.Ortho(0, 1, 0, 1, -1, 1)

		gl.MatrixMode(gl.MODELVIEW)
		gl.LoadIdentity()

		gl.Enable(gl.TEXTURE_2D)
		gl.Begin(gl.QUADS)
		gl.TexCoord2f(0, 0)
		gl.Vertex2f(0, 0)
		gl.TexCoord2f(1, 0)
		gl.Vertex2f(1, 0)
		gl.TexCoord2f(1, 1)
		gl.Vertex2f(1, 1)
		gl.TexCoord2f(0, 1)
		gl.Vertex2f(0, 1)
		gl.End()
		gl.Disable(gl.TEXTURE_2D)

		// ----------------------------------------------------
		// 2) RESET COMPLETO DELLA PIPELINE FISSA
		//    (necessario per shader OpenGL 2.1)
		// ----------------------------------------------------

		gl.MatrixMode(gl.PROJECTION)
		gl.LoadIdentity()
		gl.MatrixMode(gl.MODELVIEW)
		gl.LoadIdentity()

		// ----------------------------------------------------
		// 3) DISEGNO OVERLAY MODERNO (SHADER)
		// ----------------------------------------------------

		// DrawOverlayGL21(float32(mouseX), float32(mouseY), 200)

		// rileva errori GL (debug)
		if e := gl.GetError(); e != gl.NO_ERROR {
			fmt.Println("GL ERROR:", e)
		}

		// ----------------------------------------------------
		// 4) RITORNO ALLA PIPELINE FISSA DOPO OVERLAY
		// ----------------------------------------------------

		gl.UseProgram(0) // IMPORTANTISSIMO

		// ----------------------------------------------------

		window.SwapBuffers()
		glfw.PollEvents()
	}

}
